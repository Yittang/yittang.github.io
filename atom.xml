<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yittang</title>
  
  <subtitle>Just Do It</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-10T10:47:12.331Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yittang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指Offer第八题：跳台阶</title>
    <link href="http://yoursite.com/2017/12/10/%E5%89%91%E6%8C%87-8/"/>
    <id>http://yoursite.com/2017/12/10/剑指-8/</id>
    <published>2017-12-10T10:34:17.000Z</published>
    <updated>2017-12-10T10:47:12.331Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="此系列为牛客网剑指Offer系列。"><a href="#此系列为牛客网剑指Offer系列。" class="headerlink" title="此系列为牛客网剑指Offer系列。"></a><strong>此系列为<a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">牛客网剑指Offer系列</a>。</strong></h3><p>撰写此博文只为记录点滴与总结。</p><hr><h1 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h1><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><ul><li><strong>题目中说明青蛙要么跳1级，要么就2级。假如只有1级台阶，那么青蛙跳的方式就是F(1)=1。如果有2级台阶，F(2)=2。如果有3级台阶，F(3)=3。假如此时青蛙要跳n级台阶，那么假设青蛙第一次跳1级，那么剩下n-1级台阶的跳法，如果第一次跳2级，那么剩下n-2级台阶的跳法，所以F(n)=F(n-1)+F(n-2)，看到这个式子是不是觉得很眼熟?对，你没看错。，它就是之前的斐波那契数列的式子。虽然这题可以用递归的方式，但用递归的方式太浪费时间，用两个变量去记录前两次的跳法，显然循环会比递归效率很多。</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function jumpFloor(number)</span><br><span class="line">&#123;</span><br><span class="line">    // write code here</span><br><span class="line">    if(number &lt;= 0) &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;else if(number === 1) &#123;</span><br><span class="line">        return 1</span><br><span class="line">    &#125;else if(number === 2) &#123;</span><br><span class="line">        return 2</span><br><span class="line">    &#125;</span><br><span class="line">    let pre = 1,</span><br><span class="line">        next = 2,</span><br><span class="line">        result = 0</span><br><span class="line">    for(let i=3; i&lt;=number; i++) &#123;</span><br><span class="line">        result = pre + next</span><br><span class="line">        pre = next</span><br><span class="line">        next = result</span><br><span class="line">    &#125;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="如有帮助，请收藏本博客，谢谢！"><a href="#如有帮助，请收藏本博客，谢谢！" class="headerlink" title="如有帮助，请收藏本博客，谢谢！"></a><strong>如有帮助，请收藏本博客，谢谢！</strong></h1><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-7/4770802.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;此系列为牛客网剑指Offer系列。&quot;&gt;&lt;a href=&quot;#此系列为牛客网剑指Offer系列。&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="剑指Offer系列" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>单向链表</title>
    <link href="http://yoursite.com/2017/12/09/%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/12/09/链表/</id>
    <published>2017-12-09T10:39:19.000Z</published>
    <updated>2017-12-10T10:47:23.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h1><p>作为一个程序猿，我相信只要整日与代码为伍的动物，那肯定离不开数据结构这种恶心又让人爱的数学思维，那么今天我就整理了一下关于链表的知识。</p><h2 id="何为链表？"><a href="#何为链表？" class="headerlink" title="何为链表？"></a>何为链表？</h2><p>链表，即存储有序的元素的集合，是一种线性表，但不会按线性的顺序去存储数据。为什么会有链表呢？那就不得不稍微提一下我们经常接触的另一个数据结构：数组。数组的结构非常容易理解，并且能随意获取数组每一个位置的数据，但也有它不足之处，那就是从数组的头部或中间任意位置插入或删除项的成本非常高，所以链表诞生而出。(哈哈哈，各位看官看看就好，莫要太当真。)链表内每个元素不像数组一样，只是单纯的存储数据，而是每个元素都由一个存储元素本身的节点和一个指向下一个元素的指针组成。如下图所示，元素一个指向下一个，直到null为止。</p><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-9/45324486.jpg" alt="示意图"></p><h2 id="链表的优点"><a href="#链表的优点" class="headerlink" title="链表的优点"></a>链表的优点</h2><p>链表不像数组那样，添加一个元素时，需要移动其它元素，而是只要断开想添加的地方的指针，指向要添加的元素，再把新添加元素的指针指向原先被断开的元素，如图所示。</p><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-9/41339135.jpg" alt=""></p><p>好了，通过以上的介绍，想必现在你的脑海里一定有了对于链表一定的概念了，那么接下来让我们来看看如何创建单向链表的。</p><h2 id="Node类"><a href="#Node类" class="headerlink" title="Node类"></a>Node类</h2><h3 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Node(element) &#123;</span><br><span class="line">  this.element = element</span><br><span class="line">  this.next = null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h2><h3 id="链表的方法"><a href="#链表的方法" class="headerlink" title="链表的方法"></a>链表的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function LinkedList() &#123;</span><br><span class="line">  this.head = null //头节点</span><br><span class="line">  let length = 0 //链表长度</span><br><span class="line">  this.append = (element) =&gt; &#123;...&#125; //链尾添加元素</span><br><span class="line">  this.insert = (position, element) =&gt; &#123;...&#125; //特定位置插入元素</span><br><span class="line">  this.removeAt = (element) =&gt; &#123;...&#125; //移除特定元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>接下来就分别看链表的方法</p><h4 id="append"><a href="#append" class="headerlink" title="append"></a>append</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">this.append = (element) =&gt; &#123;</span><br><span class="line">    let node = new Node(element)</span><br><span class="line">    if(this.head === null) &#123;</span><br><span class="line">        this.head = node</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        let current = this.head</span><br><span class="line">        while(current.next) &#123;</span><br><span class="line">            current = current.next</span><br><span class="line">        &#125;</span><br><span class="line">        current.next = node</span><br><span class="line">        length++</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>我们来分析下，当要向链表添加某个元素时，首先判断是否存在头节点。如果头节点为空，那么我们就把头节点指向我们创建的元素节点，那么也就是整个链表现在只有头节点。如果不为空，因为append方法是向链表的尾部添加新元素，所以我们要找到这个链表的尾部，那么什么情况下说明我们当前元素是最后一个元素？只有当最后一个元素的指针指向null的时候就是了，所以先把当前指针指向头节点，然后开始遍历整个链表直到最后一个元素，此时把最后一个元素的指针指向我们新元素即可。</strong></p></li></ul><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-10/17389624.jpg" alt=""></p><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">this.insert = (position, element) =&gt; &#123;</span><br><span class="line">    if(position &gt;= 0 &amp;&amp; position &lt;= length) &#123;</span><br><span class="line">        let node = new Node(element),</span><br><span class="line">        current = this.head, //当前元素指向头节点</span><br><span class="line">        previous, //新元素的前一元素</span><br><span class="line">        index = 0   </span><br><span class="line">        if(position === 0) &#123; //头节点位置插入新元素</span><br><span class="line">            node.next = current</span><br><span class="line">            this.head = node</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            while(index &lt; position) &#123;</span><br><span class="line">                previous = current</span><br><span class="line">                current = current.next</span><br><span class="line">                index++</span><br><span class="line">            &#125;</span><br><span class="line">            previous.next = node</span><br><span class="line">            node.next = current</span><br><span class="line">        &#125;</span><br><span class="line">        length++</span><br><span class="line">        return true </span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return false //位置不合理，直接返回</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>首先要判断要插入新元素的位置是否在链表长度范围内，如果合理才去插入新元素。插入新元素的位置两种可能，一种在头节点，另一种在链表的中间的某一位置，因为这两种情况都要从头节点开始，所以我们把当前元素指向头节点，这样方便我们后面去遍历整个链表。先来看如果我们的新元素要插在头节点位置，那么我们的新元素的指针指向当前元素，头节点指向新元素，这就完成了头节点插入新元素。如图</strong></li></ul><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-9/36369871.jpg" alt="头节点插入新元素"></p><ul><li><strong>如果新元素插在链表的任意位置，那么就要从头开始遍历整个链表，所以我们就要循环访问整个链表，直到当index值等于我们要插入新元素位置的值一样时，跳出循环，此时我们得到两个元素，一个previous，是新元素的前一个元素，current当前值，是新元素的后一个元素，所以只要让前一个元素指向性元素，新元素指向当前值就完成了insert方法。</strong></li></ul><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-10/8907085.jpg" alt=""></p><h4 id="removeAt"><a href="#removeAt" class="headerlink" title="removeAt"></a>removeAt</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">this.removeAt = (position) =&gt; &#123;</span><br><span class="line">    if(position &gt;= 0 &amp;&amp; position &lt; length) &#123; //删除链表的位置合理</span><br><span class="line">        let current = this.head,</span><br><span class="line">        index = 0,</span><br><span class="line">        previous</span><br><span class="line">        if(position === 0) &#123;</span><br><span class="line">            this.head = current.next</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            while(index &lt; position) &#123;</span><br><span class="line">                previous = current</span><br><span class="line">                current = current.next</span><br><span class="line">                index++</span><br><span class="line">            &#125;</span><br><span class="line">            previous.next = current.next</span><br><span class="line">            length--</span><br><span class="line">        &#125;</span><br><span class="line">        return current.element</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>任意位置删除链表的元素，其实跟insert方法非常的相似。我们先来看假如删除头元素，只要让头节点指向当前元素的下一节点就是删除了。另一种情况是任意位置删除元素，我们还是要从头开始遍历整个链表，要被删除的元素的前一元素只要指向被删除元素的下一节点也就算删除了。</strong></li></ul><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-10/72220608.jpg" alt=""></p><p>好了，关于单向链表的知识点就讲到这，如有需要请自己多多去深入挖掘。:)</p><hr><h1 id="如有帮助，请收藏本博客，谢谢！"><a href="#如有帮助，请收藏本博客，谢谢！" class="headerlink" title="如有帮助，请收藏本博客，谢谢！"></a><strong>如有帮助，请收藏本博客，谢谢！</strong></h1><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-7/4770802.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单向链表&quot;&gt;&lt;a href=&quot;#单向链表&quot; class=&quot;headerlink&quot; title=&quot;单向链表&quot;&gt;&lt;/a&gt;单向链表&lt;/h1&gt;&lt;p&gt;作为一个程序猿，我相信只要整日与代码为伍的动物，那肯定离不开数据结构这种恶心又让人爱的数学思维，那么今天我就整理了一下关于链
      
    
    </summary>
    
      <category term="链表" scheme="http://yoursite.com/categories/%E9%93%BE%E8%A1%A8/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer第七题：斐波那契数列</title>
    <link href="http://yoursite.com/2017/12/09/%E5%89%91%E6%8C%87-7/"/>
    <id>http://yoursite.com/2017/12/09/剑指-7/</id>
    <published>2017-12-09T10:29:37.000Z</published>
    <updated>2017-12-09T10:35:09.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="此系列为牛客网剑指Offer系列。"><a href="#此系列为牛客网剑指Offer系列。" class="headerlink" title="此系列为牛客网剑指Offer系列。"></a><strong>此系列为<a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">牛客网剑指Offer系列</a>。</strong></h3><p>撰写此博文只为记录点滴与总结。</p><hr><h1 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h1><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39</p><ul><li><strong><a href="https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" target="_blank" rel="noopener">斐波那契数列</a>，简而言之，就是这个数列就是F(0)=0，F(1)=1，F(n)=F(n-1)+F(n-2)…从第二项开始这个数列每一项都是前两项的和，所以思路也就是求前两项之和。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function Fibonacci(n)</span><br><span class="line">&#123;</span><br><span class="line">    // write code here</span><br><span class="line">    if(n &gt; 39 || n &lt; 0) &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    let arr = []</span><br><span class="line">    arr[0] = 0</span><br><span class="line">    arr[1] = 1</span><br><span class="line">    for(let i=2; i&lt;=n; i++) &#123;</span><br><span class="line">        arr[i] = arr[i-1] + arr[i-2]</span><br><span class="line">    &#125;</span><br><span class="line">    return arr[n]  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="如有帮助，请收藏本博客，谢谢！"><a href="#如有帮助，请收藏本博客，谢谢！" class="headerlink" title="如有帮助，请收藏本博客，谢谢！"></a><strong>如有帮助，请收藏本博客，谢谢！</strong></h1><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-7/4770802.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;此系列为牛客网剑指Offer系列。&quot;&gt;&lt;a href=&quot;#此系列为牛客网剑指Offer系列。&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="剑指Offer系列" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer第六题：旋转数组的最小数字</title>
    <link href="http://yoursite.com/2017/12/08/%E5%89%91%E6%8C%87-6/"/>
    <id>http://yoursite.com/2017/12/08/剑指-6/</id>
    <published>2017-12-08T14:58:47.000Z</published>
    <updated>2017-12-08T17:28:13.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="此系列为牛客网剑指Offer系列。"><a href="#此系列为牛客网剑指Offer系列。" class="headerlink" title="此系列为牛客网剑指Offer系列。"></a><strong>此系列为<a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">牛客网剑指Offer系列</a>。</strong></h3><p>撰写此博文只为记录点滴与总结。</p><hr><h1 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h1><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><ul><li><strong>根据题目考虑两种情况，一种数组没有元素，则返回0，另一种有元素，但是是经过旋转之后并且非递减排序的，那么此时要找到数组的最小值就不能直接获取了。这时候要获取数组的最小值虽然能通过遍历能获得，但是效率太低，所以我采用了<a href="http://yuedm.blog.163.com/blog/static/188306019201151495859300/" target="_blank" rel="noopener">二分法</a>。因为题目原数组是有序的，只是经过旋转之后变的没有序，但是有一点得清除，虽然经过旋转之后没有序，但是在最小值的左边和右边都是递增型的，这时候通过数组的首值(left)中间值(mid)进行比较，当首值小于等于中间值时，说明中间值在前递增数组内，那么最小值在中间值的右边，所以此时把mid的index赋给left的index，这样再去遍历右边的数组，而不需要遍历左边的数组 ；如果首值大于中间值时，说明中间值在右边的递增数组内，那么最小值在中间值的左边，所以此时把mid的index赋给right的index，这样也就不用去遍历右边的数组。往后以此类推。</strong></li><li>可能有点绕，还是上代码比较能让你理解。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function minNumberInRotateArray(rotateArray)</span><br><span class="line">&#123;</span><br><span class="line">    // write code here</span><br><span class="line">    let len = rotateArray.length</span><br><span class="line">    if(!len) &#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">    let left = 0,</span><br><span class="line">        right = len - 1,</span><br><span class="line">        mid = 0</span><br><span class="line">    while(rotateArray[left] &gt;= rotateArray[right]) &#123; //说明数组旋转过</span><br><span class="line">        if(right - left == 1) &#123; //数组只有两个元素，最小值一定是第二个</span><br><span class="line">            mid = right</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        mid = Math.floor((right + left)/ 2)</span><br><span class="line">        //首值，中间值，最后值相同只能去遍历</span><br><span class="line">        if (rotateArray[left] == rotateArray[mid] &amp;&amp; rotateArray[right] == rotateArray[mid]) &#123;</span><br><span class="line">            let min = rotateArray[left]</span><br><span class="line">            for(let i=left+1; i&lt;=right; i++) &#123;</span><br><span class="line">                if(rotateArray[i] &lt; min) &#123;</span><br><span class="line">                    min = rotateArray[i]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return min</span><br><span class="line">        &#125;</span><br><span class="line">        if(rotateArray[left] &lt;= rotateArray[mid]) &#123;</span><br><span class="line">            left = mid</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return rotateArray[mid]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="如有帮助，请收藏本博客，谢谢！"><a href="#如有帮助，请收藏本博客，谢谢！" class="headerlink" title="如有帮助，请收藏本博客，谢谢！"></a><strong>如有帮助，请收藏本博客，谢谢！</strong></h1><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-7/4770802.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;此系列为牛客网剑指Offer系列。&quot;&gt;&lt;a href=&quot;#此系列为牛客网剑指Offer系列。&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="剑指Offer系列" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer第五题：用两个栈实现队列</title>
    <link href="http://yoursite.com/2017/12/07/%E5%89%91%E6%8C%87-5/"/>
    <id>http://yoursite.com/2017/12/07/剑指-5/</id>
    <published>2017-12-07T12:20:52.000Z</published>
    <updated>2017-12-07T13:03:09.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="此系列为牛客网剑指Offer系列。"><a href="#此系列为牛客网剑指Offer系列。" class="headerlink" title="此系列为牛客网剑指Offer系列。"></a><strong>此系列为<a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">牛客网剑指Offer系列</a>。</strong></h3><p>撰写此博文只为记录点滴与总结。</p><hr><h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型</p><ul><li><strong><a href="https://www.cnblogs.com/VitoCorleone/archive/2014/06/12/3784468.html" target="_blank" rel="noopener">队列</a>跟栈稍微有点不同,是只允许在一端进行插入操作，在另一端进行删除操作的线性表。但从其字面意思上就能猜到跟我们日常生活中排队一样，谁先进的队伍谁在前面，也就会先出去。所以队列的意义就是：先进先出，从尾部进入，从头部出去。所以，我们这里又可以愉快的用到JS数组的方法了，不清楚js数组的方法的可以看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="noopener">mdn</a>。言归正传，数组常用的方法push就是将一个或多个元素添加到数组的末尾，shift就是从数组中删除第一个元素。这不就是我们需要的队列的方法么？好了接下来一切都简单了。我们只需要一个模拟的栈用push，另一个用来pop。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let stackA = [],</span><br><span class="line">    stackB = []</span><br><span class="line">function push(node)</span><br><span class="line">&#123;</span><br><span class="line">    // write code here</span><br><span class="line">    stackA.push(node)</span><br><span class="line">&#125;</span><br><span class="line">function pop()</span><br><span class="line">&#123;</span><br><span class="line">    // write code here</span><br><span class="line">    stackB = stackA.shift()</span><br><span class="line">    return stackB</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="如有帮助，请收藏本博客，谢谢！"><a href="#如有帮助，请收藏本博客，谢谢！" class="headerlink" title="如有帮助，请收藏本博客，谢谢！"></a><strong>如有帮助，请收藏本博客，谢谢！</strong></h1><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-7/4770802.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;此系列为牛客网剑指Offer系列。&quot;&gt;&lt;a href=&quot;#此系列为牛客网剑指Offer系列。&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="剑指Offer系列" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer第四题：重建二叉树</title>
    <link href="http://yoursite.com/2017/12/06/%E5%89%91%E6%8C%87-4/"/>
    <id>http://yoursite.com/2017/12/06/剑指-4/</id>
    <published>2017-12-06T14:04:59.000Z</published>
    <updated>2017-12-07T12:30:59.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="此系列为牛客网剑指Offer系列。"><a href="#此系列为牛客网剑指Offer系列。" class="headerlink" title="此系列为牛客网剑指Offer系列。"></a><strong>此系列为<a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">牛客网剑指Offer系列</a>。</strong></h3><p>撰写此博文只为记录点滴与总结。</p><hr><h1 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h1><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><ul><li>请先了解<a href="http://baike.sogou.com/v111776.htm?fromTitle=%E4%BA%8C%E5%85%83%E6%A8%B9" target="_blank" rel="noopener">什么叫二叉树</a></li><li><strong>因为输入的是前序序列和中序序列，那么我们能直接通过前序序列知道二叉树的根节点，然后通过中序序列直接知道二叉树的左子树(此记为中左子树)和右子树(此记为中右子树)有哪些节点。这样我们就能通过中左子树来得到前序序列中的左子树(记为前左子树)和右子树(记为前右子树)。然后通过递归思想，我们把前左子树传入当作新前序序列，中左子树当作新中序序列，来得到左子树的头结点和左子树包含的哪些节点，以此递归下去，右子树也是一样的思想。</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* function TreeNode(x) &#123;</span><br><span class="line">    this.val = x;</span><br><span class="line">    this.left = null;</span><br><span class="line">    this.right = null;</span><br><span class="line">&#125; */</span><br><span class="line">function reConstructBinaryTree(pre, vin)</span><br><span class="line">&#123;</span><br><span class="line">    // write code here</span><br><span class="line">    if(!pre.length || !vin.length) &#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    const val = pre[0] //根节点</span><br><span class="line">    const index = vin.indexOf(val) //根节点在右子树的index位置</span><br><span class="line">    let preLeft = pre.slice(1, index+1) //前左子树</span><br><span class="line">    let preRight = pre.slice(index+1) //前右子树</span><br><span class="line">    let vinLeft = vin.slice(0, index) //中左子树</span><br><span class="line">    let vinRight = vin.slice(index+1) //中右子树</span><br><span class="line">    return &#123;</span><br><span class="line">        val: val,</span><br><span class="line">        left: reConstructBinaryTree(preLeft, vinLeft),</span><br><span class="line">        right: reConstructBinaryTree(preRight, vinRight)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="如有帮助，请收藏本博客，谢谢！"><a href="#如有帮助，请收藏本博客，谢谢！" class="headerlink" title="如有帮助，请收藏本博客，谢谢！"></a><strong>如有帮助，请收藏本博客，谢谢！</strong></h1><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-7/4770802.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;此系列为牛客网剑指Offer系列。&quot;&gt;&lt;a href=&quot;#此系列为牛客网剑指Offer系列。&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="剑指Offer系列" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer第三题：从尾到头打印链表</title>
    <link href="http://yoursite.com/2017/12/05/%E5%89%91%E6%8C%87-3/"/>
    <id>http://yoursite.com/2017/12/05/剑指-3/</id>
    <published>2017-12-05T13:37:34.000Z</published>
    <updated>2017-12-07T12:30:58.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="此系列为牛客网剑指Offer系列。"><a href="#此系列为牛客网剑指Offer系列。" class="headerlink" title="此系列为牛客网剑指Offer系列。"></a><strong>此系列为<a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">牛客网剑指Offer系列</a>。</strong></h3><p>撰写此博文只为记录点滴与总结。</p><hr><h1 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h1><p>输入一个链表，从尾到头打印链表每个节点的值。</p><ul><li>什么叫<a href="http://www.baike.com/wiki/%E9%93%BE%E8%A1%A8" target="_blank" rel="noopener">链表</a>，如果不清楚的可以先去了解下，接下来直接进入正题！</li><li><strong>题目：反向打印链表的所有节点。因为链表中每个节点包含的是本身节点的信息(value)和指向下一节点的指针，所以我们需要获取的就是这个value，但是要遍历所有节点，所以我们不可避免的需要用到这个指针。那么我们该如何反向输出整个链表呢？这时候链表的表亲=&gt;数组登场了，JS数组的API非常强大，本身属性方法中就有push、pop、unshift、shift等操作数组方法。既然题目要反向输出，而且链表是从头指向下一级，直到为null才结束，所以我们只要每次取到一个链表节点的时候，把它从数组的头部放入，也就是栈的思想，后进节点的永远在最前面，那么这样数组中就保存了整个反向链表，直接就能输出了！</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*function ListNode(x)&#123;</span><br><span class="line">    this.val = x;</span><br><span class="line">    this.next = null;</span><br><span class="line">&#125;*/</span><br><span class="line">function printListFromTailToHead(head)</span><br><span class="line">&#123;</span><br><span class="line">    // write code here</span><br><span class="line">    let arr = []</span><br><span class="line">    while(head) &#123;</span><br><span class="line">        arr.unshift(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    &#125;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="如有帮助，请收藏本博客，谢谢！"><a href="#如有帮助，请收藏本博客，谢谢！" class="headerlink" title="如有帮助，请收藏本博客，谢谢！"></a><strong>如有帮助，请收藏本博客，谢谢！</strong></h1><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-7/4770802.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;此系列为牛客网剑指Offer系列。&quot;&gt;&lt;a href=&quot;#此系列为牛客网剑指Offer系列。&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="剑指Offer系列" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer第二题：替换空格</title>
    <link href="http://yoursite.com/2017/12/04/%E5%89%91%E6%8C%87-2/"/>
    <id>http://yoursite.com/2017/12/04/剑指-2/</id>
    <published>2017-12-04T14:29:09.000Z</published>
    <updated>2017-12-07T12:30:57.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="此系列为牛客网剑指Offer系列。"><a href="#此系列为牛客网剑指Offer系列。" class="headerlink" title="此系列为牛客网剑指Offer系列。"></a><strong>此系列为<a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">牛客网剑指Offer系列</a>。</strong></h3><p>撰写此博文只为记录点滴与总结。</p><hr><h1 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h1><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><ul><li><strong>JS中有一项非常强大的利器：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">正则</a>，其中有专门对应空格的匹配，和替换的方法replace</strong>。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function replaceSpace(str)</span><br><span class="line">&#123;</span><br><span class="line">    // write code here</span><br><span class="line">    let reg = /\s/g</span><br><span class="line">    str = str.replace(reg, &quot;%20&quot;)</span><br><span class="line">    return str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h1 id="如有帮助，请收藏本博客，谢谢！"><a href="#如有帮助，请收藏本博客，谢谢！" class="headerlink" title="如有帮助，请收藏本博客，谢谢！"></a><strong>如有帮助，请收藏本博客，谢谢！</strong></h1><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-7/4770802.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;此系列为牛客网剑指Offer系列。&quot;&gt;&lt;a href=&quot;#此系列为牛客网剑指Offer系列。&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="剑指Offer系列" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer第一题：二维数组中的查找</title>
    <link href="http://yoursite.com/2017/12/04/%E5%89%91%E6%8C%87-1/"/>
    <id>http://yoursite.com/2017/12/04/剑指-1/</id>
    <published>2017-12-04T13:13:41.000Z</published>
    <updated>2017-12-07T12:30:56.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="此系列为牛客网剑指Offer系列。"><a href="#此系列为牛客网剑指Offer系列。" class="headerlink" title="此系列为牛客网剑指Offer系列。"></a><strong>此系列为<a href="https://www.nowcoder.com/ta/coding-interviews" target="_blank" rel="noopener">牛客网剑指Offer系列</a>。</strong></h3><p>撰写此博文只为记录点滴与总结。</p><hr><h1 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h1><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><ul><li><strong>一个二维数组并且内部排序是有序的，并且从左向右和从上至下都是递增的，那么也就是说每一行的最右边的元素会是最大的，此时只要拿这个数去与target作比较，就能去判断我下一步应该是换行，还是该在当前行去往前推，再去与target作比较，如此往复，就能去判断这个二维数组内部是否有target了。这种优势就是我没必要去遍历整个数组，节省很大的时间。说了这么多，还是上图比较容易理解，下面举例。</strong></li></ul><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-7/28494395.jpg" alt=""></p><ul><li>假设target为5，我们从这个二维数组的第一行的最右边(a15)去与target作比较，那么a15 &gt; 5，所以当前行往前推，a14 &gt; 5，再往前，直到a12 &lt; 5，所以要换一行，也就是b12与target作比较，这样往复去比较，就能知道这个二维数组中是否有target了。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Find(target, array)</span><br><span class="line">&#123;</span><br><span class="line">    // write code here</span><br><span class="line">    let i = 0</span><br><span class="line">    let j = array[i].length - 1</span><br><span class="line">    while(i&lt;array.length &amp;&amp; j&gt;=0) &#123;</span><br><span class="line">        if(array[i][j] &gt; target) &#123;</span><br><span class="line">            j--</span><br><span class="line">        &#125;else if(array[i][j] &lt; target) &#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="如有帮助，请收藏本博客，谢谢！"><a href="#如有帮助，请收藏本博客，谢谢！" class="headerlink" title="如有帮助，请收藏本博客，谢谢！"></a><strong>如有帮助，请收藏本博客，谢谢！</strong></h1><p><img src="http://p0kkg0pkm.bkt.clouddn.com/17-12-7/4770802.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;此系列为牛客网剑指Offer系列。&quot;&gt;&lt;a href=&quot;#此系列为牛客网剑指Offer系列。&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="剑指Offer系列" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87Offer%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="JS" scheme="http://yoursite.com/tags/JS/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>初识Git与GitHub</title>
    <link href="http://yoursite.com/2017/12/02/%E8%AE%A4%E8%AF%86Git%E4%B8%8EGitHub/"/>
    <id>http://yoursite.com/2017/12/02/认识Git与GitHub/</id>
    <published>2017-12-02T08:02:21.000Z</published>
    <updated>2017-12-05T14:03:31.073Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/5875188-15ad88a4b9c019ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持Git作为唯一的版本库格式进行托管，故名 GitHub。</p><h1 id="Git的安装"><a href="#Git的安装" class="headerlink" title="Git的安装"></a>Git的安装</h1><ol><li>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a></li><li>在使用GitHub之前首先要安装<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li><li>具体如何安装可以看<a href="https://jingyan.baidu.com/article/90895e0fb3495f64ed6b0b50.html" target="_blank" rel="noopener">这篇</a></li></ol><h1 id="GitHub初体验"><a href="#GitHub初体验" class="headerlink" title="GitHub初体验"></a>GitHub初体验</h1><p>在进入<a href="https://github.com" target="_blank" rel="noopener">GitHub</a>官网，你首先要注册一个账号(ps:这个就是你个人账户，牢记！)<br><img src="http://upload-images.jianshu.io/upload_images/5875188-3f950b6801ca530a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GitHub注册"></p><p><strong>既然我们都已经迈出了第一步，是不是该体验起飞的感觉了！</strong></p><h1 id="Github仓库的创建"><a href="#Github仓库的创建" class="headerlink" title="Github仓库的创建"></a>Github仓库的创建</h1><p>不急，我们先进入主页我们会看到右边有这么一个大绿色按钮<img src="http://upload-images.jianshu.io/upload_images/5875188-d5eb719b1df0d063.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>毫不犹豫的按下它吧！！！这就是你以后经常需要触碰的仓库！<img src="http://upload-images.jianshu.io/upload_images/5875188-489861b0bb33638e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>因为我勾选了自动创建README，所以界面是这样的</p><p><img src="http://upload-images.jianshu.io/upload_images/5875188-bea021cb4078c0d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>好了，到了这一步说明已经成功了一半，仓库建好了，那么我们怎么才能把这远程仓库能clone到我们本地呢？</strong><br>仔细的你一定看到了又出现了一个大绿色按钮，没错，这就是我们的主角！点开它，你会发现右上角有个<strong>Use SSH</strong>(这是个切换按钮，记得切换到SSH)</p><p><img src="/images/GitHub/SSH.gif" alt=""></p><p>那么问题来了，<a href="http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html" target="_blank" rel="noopener">SSH</a>是啥？我没有这玩意儿啊，该怎么办？不慌！这时候该我们的Git登场了！(blingbling滑稽)</p><h1 id="Git初体验"><a href="#Git初体验" class="headerlink" title="Git初体验"></a>Git初体验</h1><ul><li>首先打开我们的Git Bash (安装成功)</li><li>因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5875188-cbcabe8f716ce752.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>然后我们可以查看我们电脑中是否已经存在过ssh，打下面两条命令就能看到，我已经安装过，所以显示存在，没有安装是显示不存在的。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5875188-53df3ff31496f5ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>接下来我们<a href="https://help.github.com/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent/" target="_blank" rel="noopener">安装SSH</a> <code>ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</code>(<strong>记得替换你自己的邮箱</strong>),把这句代码输进Git中，它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空，一直按回车结束，就成功了。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5875188-65ae659d83cda2c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>现在只需要我们去ssh目录下的id_rsa.pub中的钥匙给复制出来然后粘贴到GitHub的SSH中就行了</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5875188-317383ab7b5396a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>回到GitHub中，点击我们的头像，然后下面会出现一个Settings。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5875188-81559db0a745b145.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>如图点击New SSH key</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5875188-22764e975d7d473e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/5875188-56190c8a443a6e19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>好了，现在完成了我们的SSH创建，接下来我们就能clone我们的仓库到本地啦！</li></ul><h1 id="Clone仓库到本地"><a href="#Clone仓库到本地" class="headerlink" title="Clone仓库到本地"></a>Clone仓库到本地</h1><ul><li>回到我们的clone按钮，切换到SSH，并且复制这段地址</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/5875188-4ad0fffb24619408.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>选好你想放仓库的文件夹位置，并且右键点git bash here，输入<code>git clone git@github.com:xxx/test.git</code>(后面改成你们的地址哦)</li></ul><p><strong>然后静等仓库clone下来，然后就能愉快的玩耍GitHub啦！</strong><br><img src="http://upload-images.jianshu.io/upload_images/5875188-14b8d5f3f434237c.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5875188-15ad88a4b9c019ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
      
    
    </summary>
    
      <category term="GitHub系列" scheme="http://yoursite.com/categories/GitHub%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
  </entry>
  
</feed>
